Дата последнего обновления документа: 05.11.2010.



# Введение: Что такое Google C++ Testing Framework? #

_Google C++ Testing Framework_ (далее по тексту Google Test) призвана
помочь вам в создании качественных тестов для программ на C++.

Неважно работаете ли вы в Linux, Windows или Mac -- если вы пишете
программы на С++, то Google Test поможет вам в этом.

Что значит _хороший тест_, и как именно Google Test помогает писать
хорошие тесты?

  1. Тесты должны быть _независимыми_ и _повторяемыми_. Неудобно отлаживать тест, когда его результат зависит от других тестов. Google Test изолирует каждый тест, запуская его отдельным объектом. Если тест сбоит, то Google Test дает возможность запускать его независимо для быстрой отладки.
  1. Тесты должны быть грамотно организованны и должны отражать структуру тестируемого кода. Google Test группирует тесты в наборы (test cases), которые могут иметь общие данные и подпрограммы. Такой подход просто реализуем и позволяет легко управлять тестами. Подобное единообразие крайне полезно, когда люди переключаются с одного проекта на другой и начинают работать с новым для них кодом.
  1. Тесты должны быть переносимы на другие платформы и пригодны для повторного использования. В мире открытого программного обеспечения очень много переносимого кода, поэтому его тесты также должны быть переносимы. Google Test работает на разных операционных системах, с разными компиляторами, с поддержкой исключений или без оной, поэтому тесты в Google Test могут работать в разнообразных конфигурациях. (На данный момент имеются скрипты для сборки только под Linux -- мы работаем над скриптами для других платформ).
  1. Когда тест дает сбой, он должен предоставлять _максимум_ информации об ошибке. Google Test не останавливается при первом же сбое. Наоборот, только текущий тест прерывается, а управление передается следующему тесту. Вы можете использовать в тестах _мягкие_ (нефатальные) типы проверок, после сбоя на которых тест продолжает работу. Таким образом, вы можете обнаружить и исправить несколько ошибок в одном прогоне.
  1. Среда тестирования должна избавить автора тестов от рутинных операций и позволить сконцентрироваться непосредственно на _cмысле_ тестов. Google Test автоматически регистрирует все объявленные тесты и не требует от программиста ручного добавления их в систему запуска.
  1. Тесты должны быть _быстрыми_. В Google Test вы можете повторно использовать общие для всех тестов или какого-то конкретного тестового набора ресурсы без необходимости делать тесты зависимыми друг от друга, так как есть возможность инициализировать среду тестирования и чистить мусор только один раз. Так как Google Test построена на базе популярной архитектуры xUnit, вы будете чувствовать себя как дома, если вы раньше работали с JUnit или PyUnit. Если нет, вам потребуется 10 минут чтобы освоить основы и начать работать. Поехали!

_Замечание:_ Как упоминалось раньше, неформально мы можем ссылаться
на Google C++ Testing Framework как на _Google Test_.

# Создание нового проекта #

Для создания тестовой программы с использованием Goole Test, вам
необходимо скомпилировать Google Test в формат библиотеки и прилинковать
к вашим тестам. Мы создали необходимые скрипты и файлы конфигурации для
некоторых популярных системы сборки (`msvc/` для Visual Studio, `xcode/`
для Mac Xcode, `make/` для GNU make, `codegear/` для Borland C++
Builder, `scons/` для Scons, и скрипт для autotools в корневом каталоге
Google Test). Если вы используете другую систему сборки, возьмите за
образец файл `make/Makefile` чтобы понять, как собрать Google Test (по
сути вам надо скомпилировать `src/gtest-all.cc` со значениями `GTEST_ROOT`
и `GTEST_ROOT/include` в списке путей для заголовочных файлов, где
`GTEST_ROOT` является корневым каталогом директории Google Test).
Скомпилировав Google Test как библиотеку, мы можете создать новый
проект. Убедитесь, что путь `GTEST_ROOT/include` включен в список поиска
заголовочных файлов, чтобы компилятор смог найти `<gtest/gtest.h>`.
Проект должен быть слинкован с библиотекой Google Test (например, для
Visual Studio, вы можете добавить зависимость от `gtest.vcproj`). Если
какие-то моменты остались неясными, посмотрите, посмотрие, как устроены
тесты самой библиотеки Google Test, и используйте их в качестве примера.

# Основные понятия #

Работая с Google Test, вы пишете _утверждения_, которые являются
операторами проверки истинности некоторого условия. Проверка утверждения может
закончится _успехом_, _фатальной ошибкой_ (_fatal error_) или
_нефатальной ошибкой_ (_non-fatal error_). При фатальной ошибке
выполнение текущего теста прерывается. В противном случае программа
просто продолжает работу дальше.

_Тесты_ используют утверждения для проверки логики работы программного
кода. Если тест аварийно завершается или какое-либо утверждение в нем не
срабатывает, то считается, что тест _дал сбой_, иначе тест считается
_успешным_.

Вы можете группировать тесты в _наборы_ (_test cases_), сообразно
структуре тестируемой программы. Если несколько тестов используют общие
объекты и подпрограммы, вы может объединить их в _тестовый класс_ (_test
fixture_).

_Тестовая программа_ может состоять из нескольких наборов тестов.

Мы покажем, как писать тестовую программу, начиная с уровня отдельных
утверждений, затем поднимаясь на уровень тестовых наборов и тестовых классов.

# Утверждения #

Утверждения в Google Test являются макросами, схожими с вызовами
функций. Вы тестируете класс или функцию, делая логические постулаты
(утверждения) об их ожидаемом поведении. Когда такой постулат
нарушается, Google Test печатает имя файла и номер строки, где
произошел сбой. Также выводится диагностическое сообщение об ошибке. Вы
можете задавать свои собственные дополнительные сообщения, которые будут
добавлены к стандартному.

Утверждения бывают двух типов, схожих по названию, но по разному
влияющих на выполнение текущего теста. `ASSERT_*` генерируют фатальные
ошибки, при возникновении которых **выполнение текущей функции
прерывается**. Другой тип, `EXPECT_*`, генерирует "мягкие", нефатальные
ошибки, которые не прерывают текущую функцию. Такие утверждения являются
более предпочтительными, так как дают возможность обнаружить сразу несколько
проблем в тесте. Однако вам следует использовать `ASSERT_*`, если уже
не имеет смысла продолжать тест после сбоя.

Когда показавший ошибку `ASSERT_*` немедленно прерывает выполнение
текущей функции, возможно, что часть кода, ответственного за чистку
мусора и освобождение ресурсов после теста, не будет выполнена, что
может привести к утечкам памяти. В зависимости от типа утечки может и не
стоит заботиться о них в данном случае, но надо быть готовым к возможным
сообщениям об ошибках от систем проверки динамически распределенной
памяти.

Чтобы вывести свое собственное сообщение об ошибке, просто используйте
макрос утверждения как стандартный поток и оператор `<<`. Например:
```
ASSERT_EQ(x.size(), y.size()) << "Длина вектора x не равна длине вектора y";

for (int i = 0; i < x.size(); ++i) {
  EXPECT_EQ(x[i], y[i]) << "Вектора x и y отличаются по индексу " << i;
}
```

Все, что может быть выведено в поток ostream можно послать подобным же
образом в макрос утверждения. В частности, строки языка С и объекты
`string`. Если печатается широкая строка (`wchar_t*`, `TCHAR*` в
режиме `UNICODE` в Windows, или `std::wstring`), то она будет
преобразована в кодировку UTF-8.

## Основные типы утверждений ##

Данные утверждения проверяют условие на истинность или ложность.
| **Фатальное утверждение** | **Нефатальное утверждение** | **Цель проверки** |
|:--------------------------|:----------------------------|:------------------|
| `ASSERT_TRUE(`_условие_`)`;  | `EXPECT_TRUE(`_условие_`)`;   | _условие_ истино  |
| `ASSERT_FALSE(`_условие_`)`; | `EXPECT_FALSE(`_условие_`)`;  | _условие_ ложно   |

Обратите внимание, что когда утверждение дает сбой, `ASSERT_*`
генерирует фатальную ошибку и прекращает выполнение текущей функции,
тогда как `EXPECT_*` генерирует "мягкую", нефатальную ошибку, и текущая
функция продолжает выполнение. В любом случае считается, что данный тест
в целом дал сбой.


_Доступно на_: Linux, Windows, Mac.

## Сравнения ##

Этот раздел описывает утверждения для сравнение друх значений.

| **Фатальное утверждение** | **Нефатальное утверждение** | **Цель проверки** |
|:--------------------------|:----------------------------|:------------------|
|`ASSERT_EQ(`_ожидаемое_`, `_действительное_`);`|`EXPECT_EQ(`_ожидаемое_`, `_действительное_`);`| _ожидаемое_ `==` _действительное_ |
|`ASSERT_NE(`_знач1_`, `_знач2_`);`      |`EXPECT_NE(`_знач1_`, `_знач2_`);`      | _знач1_ `!=` _знач2_ |
|`ASSERT_LT(`_знач1_`, `_знач2_`);`      |`EXPECT_LT(`_знач1_`, `_знач2_`);`      | _знач1_ `<` _знач2_ |
|`ASSERT_LE(`_знач1_`, `_знач2_`);`      |`EXPECT_LE(`_знач1_`, `_знач2_`);`      | _знач1_ `<=` _знач2_ |
|`ASSERT_GT(`_знач1_`, `_знач2_`);`      |`EXPECT_GT(`_знач1_`, `_знач2_`);`      | _знач1_ `>` _знач2_ |
|`ASSERT_GE(`_знач1_`, `_знач2_`);`      |`EXPECT_GE(`_знач1_`, `_знач2_`);`      | _знач1_ `>=` _знач2_ |

В случае ошибки Google Test печатает оба значение _знач1_ и _знач2_. В
`ASSERT_EQ*` и `EXPECT_EQ*` (все остальные варианты проверки на равенство будут
рассмотрены чуть позже) вы задаете выражение, которое хотите проверить,
в параметре _действительное_, а ожидаемое значение -- в параметре
_ожидаемое_. Следование такому соглашению удобно тем, что Google Test
печатает сообщения об ошибках, исходя именного из такого использования
параметров утверждения.

Значения аргументов должны иметь возможность сравнения. Иначе вы
получите сообщение компилятора об ошибке. Значения также должны
поддерживать оператор `<<` для вывода в поток `ostream`. Все встроенные
типы данных удовлетворяют этим условиям.

Утверждения могут работать с пользовательскими типами, но только если вы
зададите соответственные операторы сравнения (например, `==`, `<` и
т.д.). Если соответственный оператор определен, то предпочтительнее
использовать макросы `ASSERT_*()`, так как они печатают не только
результат сравнения, но сами операнды.

Аргументы всегда вычисляются только один раз, поэтому можно спокойно
использовать вызовы с побочными эффектами. Однако, в языках С и С++
порядок вычисления аргументов функций не определен, и компилятор может их
вычислить в любом порядке, поэтому нельзя полагаться на определенный
порядок вычисления аргументов утверждения.

`ASSERT_EQ()` поддерживает сравнение указателей. Если это две строки С,
будет проверено, указывают ли они на одну и ту же область памяти, а
не значения самих строк. Если же вы хотите сравнить
значения двух строк С (например, `const char*`), то используйте макрос
`ASSERT_STREQ()`, которое будет описано ниже. В частности, для проверки
строки С на `NULL` используйте `ASSERT_STREQ(NULL, c_string)`, однако
для сравнения двух объектов типа `string` надо использовать `ASSERT_EQ`.

Макросы, описанные в данном разделе, работают с обычными и многобайтовыми
строковыми объектами (`string` и `wstring`) и строками С.

_Доступно на_: Linux, Windows, Mac.

## Сравнение строк ##

Утверждения в данной группе все сравнивают **строки С**. Если вы хотите
сравнить два объекта типа `string`, то используйте вместо них
`EXPECT_EQ`, `EXPECT_NE` и т.д.

| **Фатальное утверждение** | **Нефатальное утверждение** | **Цель проверки** |
|:--------------------------|:----------------------------|:------------------|
| `ASSERT_STREQ(`_ожидаемая__стр_`, `_действительная__стр_`);`    | `EXPECT_STREQ(`_ожидаемая__стр_`, `_действительная__стр_`);`     | две строки С содержат одинаковые значения |
| `ASSERT_STRNE(`_стр1_`, `_стр2_`);`    | `EXPECT_STRNE(`_стр1_`, `_стр2_`);`     | две строки С содержат разные значения |
| `ASSERT_STRCASEEQ(`_ожидаемая__стр_`, `_действительная__стр_`);`    | `EXPECT_STREQ(`_ожидаемая__стр_`, `_действительная__стр_`);`     | две строки С содержат одинаковые значения без учета регистра |
| `ASSERT_STRCASENE(`_стр1_`, `_стр2_`);`    | `EXPECT_STRNE(`_стр1_`, `_стр2_`);`     | две строки С содержат разные значения без учета регистра |

Обратите внимание, что "CASE" в имени утверждения означает, то регистр
будет проигнорирован.

`*STREQ*` и `*STRNE*` также могут работать с многобайтовыми строками С
(`wchar_t*`). В случае неудачного сравнения двух многобайтовых строк,
их значения буду напечатаны в виде однобайтовых строк в формате UTF-8.

Значение указателя `NULL` и пустая строка являются **разными** значениям.

_Доступно на_: Linux, Windows, Mac.

См. также: Более подробная информация о приемах сравнения (например,
подстроки, префиксы и регулярные выражения), см.
[Advanced Google Test Guide](http://code.google.com/p/googletest/wiki/AdvancedGuide).

# Элементарные тесты #

Для создания теста:
  1. Используйте макрос `TEST()` для определения функции теста. Это обычная функция языка С++, которая не имеет возвращаемого значения.
  1. В этой функции можно использовать любые корректные операторы С++ вместе с утверждениями Google Test для проверки значений.
  1. Результат теста определяется утверждениями; если хоть одно утверждение в тесте дало ошибку (фатальную или нефатальную), или если тест завершился аварийно, но тест в целом считается сбойным. В противном случае, тест регистрируется как успешный.

```
TEST(имя_набора_тестов, имя_теста) {
 ... тело_теста ...
}
```

Аргуметы макроса `TEST()` идут от общего к частному. _Первый_ аргумент
является именем набора тестов, а _второй_ -- именем теста в данном
наборе. Набор тестов может содержать любое количество отдельных тестов.
_Полное имя_ теста состоит из имени набора, которому этот тест
принадлежит, и его собственного имени. Тесты из разных наборов могут
иметь одинаковые собственные имена.

Например, имеется функция, возвращающая целое:
```
int Factorial(int n); // Вернуть факториал n
```

Тест для этой функции может быть таким:
```
// Проверить факториал от 0.
TEST(FactorialTest, HandlesZeroInput) {
  EXPECT_EQ(1, Factorial(0));
}

// Проверить факториал некоторых положительных значений.
TEST(FactorialTest, HandlesPositiveInput) {
  EXPECT_EQ(1, Factorial(1));
  EXPECT_EQ(2, Factorial(2));
  EXPECT_EQ(6, Factorial(3));
  EXPECT_EQ(40320, Factorial(8));
}
```

Google Test группирует результаты тестов по наборам, так что связанные
по смыслу тесты должны быть в одном наборе; другими словами, первый
аргумент их `TEST()` должен быть одинаковым. В приведенном выше примере
вы имеем два теста, `HandlesZeroInput` and `HandlesPositiveInput`,
принадлежащих одному набору с именем `FactorialTest`.

_Доступно на_: Linux, Windows, Mac.

# Тестовые классы: использования единой конфигурации для нескольких тестов #

В какой-то момент вы может обнаружить, что пишите несколько тестов,
использующих одинаковые данные. В этом случае можно задействовать
_тестовые классы_, что позволит повторно использовать одну и ту же
конфигурацию объектов для нескольких различных тестов.

Для создания тестового класса:
  1. Унаследуйте свой класс от `::testing::Test`. Начните описание класса с `protected:` или `public:` чтобы дать подклассам тестового класса доступ к его членам.
  1. Внутри класса объявите любые объекты, которые планируете использовать.
  1. Если это необходимо, напишите конструктор по умолчанию или функцию `SetUp()` для инициализации объекта для каждого теста. Распространенной ошибкой является написание `SetUp()` как `Setup()`, то есть со строчной буквой `u` -- не делайте этого.
  1. Если требуется, также напишите деструктор или функцию `TearDown()` для освобождения ресурсов, распределенных в `SetUp()`. Для более подробной информации о том, когда использовать конструктор/деструктор, а когда `SetUp()/TearDown()`, обратитесь к этому [вопросу в FAQ](http://code.google.com/p/googletest/wiki/FAQ#Should_I_use_the_constructor/destructor_of_the_test_fixture_or_t).
  1. Если необходимо, объявите подпрограммы, которые ваши тесты будут использовать.

Когда используете тестовый класс, пишите `TEST_F()` вместе `TEST()`, что
даст тесту доступ к объектам и подпрограммам тестового класса.
```
TEST_F(имя_набора_тестов, имя_теста) {
 ... тело_теста ...
}
```

Как и у `TEST()` первый аргумент -- это имя набора тестов, но для
`TEST_F()` он должен совпадать с именем тестового класса. Возможно вы
догадались: `_F` от английского _fixture_.

С сожалению система макросов в С++ не позволяет нам создать единый макрос,
который бы поддерживал оба типа тестов. Использование неправильного
макроса приведет к ошибке компиляции.

Также вы должны объявить тестовый класс до использования его имени в
`TEST_F()`, иначе вы получите ошибку компиляции "virtual outside class
declaration".

Для теста, объявленного с помощью `TEST_F()`, Google Test:
  1. Создаст _новый_ экземпляр тестового класса в процессе выполнения.
  1. Сразу же проиницилизирует его через `SetUp()`.
  1. Запустит тест.
  1. Вызовет `TearDown()` для чистки мусора.
  1. Удалит экземпляр тестового класса. Каждый тест в тестовом наборе будет работать со своим собственным экземпляром тестового класса, а Google Test всегда удаляет предыдущий экземпляр тестового класса перед созданием следующего.

Google Test не использует повторно один и тот же экземпляр тестового
класса для разных тестов. Любые изменения, которые тест может сделать в
очередном экземпляре тестового класса, не затрагивают остальные тесты.

Как пример, давайте напишем тест для очереди типа FIFO с именем `Queue`,
имеющей следующий интерфейс:
```
template <typename E> // E - типа элемента.
class Queue {
 public:
  Queue();
  void Enqueue(const E& element);
  E* Dequeue(); // Возвращает NULL, если очередь пуста.
  size_t size() const;
  ...
};
```

Сначала определяем тестовый класс. По соглашению вам стоит назвать его
`FooTest`, где `Foo` - имя тестируемого класса.
```
class QueueTest : public ::testing::Test {
 protected:
  virtual void SetUp() {
    q1_.Enqueue(1);
    q2_.Enqueue(2);
    q2_.Enqueue(3);
  }

  // virtual void TearDown() {}

  Queue<int> q0_;
  Queue<int> q1_;
  Queue<int> q2_;
};
```

В этом случае `TearDown()` не требуется, так как не нужно ничего освобождать
после теста в дополнение к тому, что делается в деструкторе.

Теперь напишем тесты, используя `TEST_F()` и тестовый класс.
```
TEST_F(QueueTest, IsEmptyInitially) {
  EXPECT_EQ(0, q0_.size());
}

TEST_F(QueueTest, DequeueWorks) {
  int* n = q0_.Dequeue();
  EXPECT_EQ(NULL, n);

  n = q1_.Dequeue();
  ASSERT_TRUE(n != NULL);
  EXPECT_EQ(1, *n);
  EXPECT_EQ(0, q1_.size());
  delete n;

  n = q2_.Dequeue();
  ASSERT_TRUE(n != NULL);
  EXPECT_EQ(2, *n);
  EXPECT_EQ(1, q2_.size());
  delete n;
}
```

Мы использовали оба типа утверждений: `ASSERT_*` и `EXPECT_*`.
Используйте `EXPECT_*`, если хотите, чтобы тест продолжил работу после
регистрации ошибки. Если продолжение теста бессмысленно, то используйте
`ASSERT_*`. Например, второе утверждение в тесте `Dequeue` --
`ASSERT_TRUE(n != NULL)`, так как мы собираемся разыменовывать
указатель `n` ниже, а это может закончиться нарушением защиты памяти, если
`n` равен `NULL`.

Когда все это запускается, происходит следующее:
  1. Google Test создает объект `QueueTest` (назовем его `t1`).
  1. `t1.SetUp()` инициализирует `t1`.
  1. Первый тест (`IsEmptyInitially`) использует `t1`.
  1. `t1.TearDown()` чистит мусор, когда тест закачивается.
  1. `t1` уничтожается.
  1. Все шаги повторяются снова с другим объектом `QueueTest`, который на этот раз используется в тесте `DequeueWorks`.

_Доступно на_: Linux, Windows, Mac.

_Замечание_: Google Test автоматически сохраняет все свои **настройки**, когда
тестовый объект создается и восстанавливает их, когда он уже уничтожен.

# Запуск тестов #

`TEST()` и `TEST_F()` автоматически регистрируют ваши тест в Google Test.
Так что в отличие от многих других тестовых библиотек для С++ вам не надо
вручную регистрировать тест в отдельном списке для запуска.

После объявления тестов вы можете просто вызвать функцию
`RUN_ALL_TESTS()`, которая вернет `0`, если все тесты прошли успешно, и
`1` в противном случае. `RUN_ALL_TESTS()` запускает _все тесты_ в вашем
исполняемом модуле -- тесты могут находиться в разных тестовых наборах
или разных исходных модулях.

При старте макрос `RUN_ALL_TESTS()`:
  1. Запоминает настройки Google Test.
  1. Создает объект тестового класса первого теста.
  1. Инициализирует его вызовом `SetUp()`.
  1. Запускает тест с использованием объекта тестового класса.
  1. Производит чистку мусора объекта тестового класса путем вызова `TearDown()`.
  1. Удаляет объект тестового класса.
  1. Восстанавливает настройки Google Test.
  1. Повторяет указанные шаги для всех остальных тестов.

Дополнительно, если конструктор тестового класса завершился с ошибкой на
шаге 2, шаги с 3 до 5 пропускаются. Аналогично если на шаге 3 возникает
ошибка, то шаг 4 пропускается.

_Важно_: Вы не должны игнорировать возвращаемое функцией `RUN_ALL_TESTS()`
значение, иначе `gcc` сообщит вам об ошибке. Смысл этого в том, что
автоматизированная система тестирования определяет успешность прохождения
тестов по коду возврата, а не по данным, выведенным в стандартные потоки
stdout/stderr; поэтому ваша функция `main()` должна возвращать значение,
полученное от `RUN_ALL_TESTS()`.

Также стоит помнить, что вы можете вызывать `RUN_ALL_TESTS()` только
**один** раз. Повторный ее вызов может конфликтовать с дополнительными
возможностями Google Test (например, "смертельные" тесты), и данная
возможность не поддерживается.

_Доступно на_: Linux, Windows, Mac.

# Пишем функцию main() #

Можете начать вот с такой заготовки:
```
#include "this/package/foo.h"
#include <gtest/gtest.h>

namespace {

// Тестовый класс для тестирования класса Foo.
class FooTest : public ::testing::Test {
 protected:
  // Можете удалить любую или все из функций ниже, если они пустые.

  FooTest() {
    // Здесь можно подготовить тестовые данные для каждого теста.
  }

  virtual ~FooTest() {
    // Здесь производится чистка мусора. Данная функция не должна
    // генерировать исключений.
  }

  // Если конструктор или деструктор не подходят вам для настройки
  // тестовых данных и чистки мусора, то можете использовать следующие 
  // методы:

  virtual void SetUp() {
    // Данная функция вызывается сразу после конструктора (до теста).
  }

  virtual void TearDown() {
    // Данная функция вызывается сразу после теста (до деструктора).
  }

  // Объекты, объявленные тут, могут быть использованы во всем тестовом 
  // классе Foo.
};

// Проверяем, что метод Foo::Bar() правильно выполняет задачу Abc.
TEST_F(FooTest, MethodBarDoesAbc) {
  const string input_filepath = "this/package/testdata/myinputfile.dat";
  const string output_filepath = "this/package/testdata/myoutputfile.dat";
  Foo f;
  EXPECT_EQ(0, f.Bar(input_filepath, output_filepath));
}

// Проверяем, что класс Foo правильно выполняет задачу Xyz.
TEST_F(FooTest, DoesXyz) {
  // Убеждаемся, что Xyz работает правильно в Foo.
}

}  // namespace

int main(int argc, char **argv) {
  ::testing::InitGoogleTest(&argc, argv);
  return RUN_ALL_TESTS();
}
```

Функция `::testing::InitGoogleTest()` производит разбор параметров
командной строки для Google Test и удаляет все неизвестные флаги.
Это позволяет пользователю управлять тестовой программой через различные
флаги, описанные в [Advanced Google Test Guide](http://code.google.com/p/googletest/wiki/AdvancedGuide). Вы должны вызвать эту
функцию до `RUN_ALL_TESTS()`. Иначе настройки Google Test не будут
должным образом проинициализированы.

В Windows `InitGoogleTest()` поддерживает многобайтовые строки, и может
быть скомпилирована в режиме `UNICODE`.

Резонно предположить, что написание функции main() занятие скучное.
Поэтому Google Test предоставляет уже готовую реализацию
фунции main(). Если она вас устраивает, то просто прилинкуйте библиотеку
gtest\_main и все.

## Важное замечание для пользователей Visual C++ ##

Если вы помещаете тесты в библиотеку, а ваша функция `main()` находится в
другой библиотеке или .exe файле, то такие тесты не будут работать.
Причина в
[ошибке](https://connect.microsoft.com/feedback/viewfeedback.aspx?FeedbackID=244410&siteid=210)
в Visual C++. Когда вы определяете тесты, Google Test создает
соответствующие статические объекты для их регистрации.
На эти объекты никто не ссылается, но их конструкторы все равно работают.
Когда линкер Visual C++ обнаруживает, что ни на один объект в библиотеке никто
не ссылается, он исключает такую библиотеку из линковки. Вам надо как-то
сослаться на вашу библиотеку, чтобы линкер ее не выкинул. И вот как это
делается. Где-нибудь в коде библиотеки объявите функцию:
```
__declspec(dllimport) int PullInMyLibrary() { return 0; }
```
Если вы помещаете тесты в статическую библиотеку (не DLL), тогда
`__declspec(dllexport)` не нужно. Затем в главной программе напишите код,
который будет вызывать данную функцию:
```
int PullInMyLibrary();
static int dummy = PullInMyLibrary();
```
Это создаст видимость явного использования вашей библиотеки тестами,
и позволит им быть зарегистрированными при старте.

Также, если вы помещаете тесты в статическую библиотеку, то добавьте
`/OPT:NOREF` в настройки линкера главной программы. Если вы используете
графическую среду MSVC++, то зайдите в настройки проекта .exe файла
Properties/Configuration Properties/Linker/Optimization
и установите опцию References в `Keep Unreferenced Data (/OPT:NOREF)`.
Это не даст линкеру исключить отдельные имена функций, генерируемых
вашими тестами, из конечного исполняемого файла.

Есть еще одна проблема. Если вы используете Google Test как статическую
библиотеку (как это задано в gtest.vcproj), ваши тесты также
должны находиться в статической библиотеке. Если они у вас вынуждено
находятся в DLL, вы должны скомпилировать Google Test тоже в форме DLL.
Иначе ваши тесты не будут правильно запускаться или запускаться вообще.
Из этого можно сделать вывод: для упрощения жизни -- не используйте
библиотеки для ваших тестов!

# Что дальше? #

Поздравляем! Вы освоили основы Google Test. Вы можете начать писать и
запускать тесты c Google Test, посмотреть примеры из
[Samples](http://code.google.com/p/googletest/wiki/Samples),
или продолжить читать
[Advanced Google Test Guide](http://code.google.com/p/googletest/wiki/AdvancedGuide),
где описано множество других полезных возможностей Google Test.

# Ограничения #

Google Test разработана быть безопасной для многопотокового выполнения.
Однако у нас пока нет достаточно времени для реализации механизмов
синхронизации для различных платформ. Поэтому, пока _небезопасно_
использовать утверждения Google Test параллельно в двух потоках. Для
большинства тестов это не является проблемой, когда утверждения
проверяются в главном потоке. Если хотите, то вы можете
самостоятельно разработать примитивы синхронизации в `gtest-port.h`.